<h1 id="brainstorm-for-a-probabilistic-computing-language">Brainstorm for a Probabilistic Computing Language</h1>
<p>Modern quantum programming, despite its progress, is still somewhat esoteric to the average programmer. In general, programming languages offer a midway point between a person&#8217;s mental model and literal machine instructions. Fundamentally, programming languages provide abstractions, which allow programmers to express ideas at a higher level, and have their ideas be turned into something the machine can actually do. So, the question to be resolved is: How do most programmers model algorithms, and what intermediates can make it easier to turn mental models into code?</p>
<p>There are two main goals for providing abstractions in quantum programming: - Allow novices to more quickly create useful and interesting models - Allow experienced programmers to create models more efficiently, so that they can focus on more important design aspects</p>
<p>Previous attempts at designing quantum programming languages can give insights for the design of new ones: First, there are circuit languages, which provide no abstraction, but are useful for interfacing with normal languages or compiling into. Circuit languages are also adequate for those who are already experienced with quantum programming. Second, there are the quantum-annealing family of languages, which can actually provide abstraction, but limit the scope of solvable problems. Third, there are existing attempts at higher-level universal gate languages.</p>
<p>I&#8217;ll chose one example from each class: - Rigetti pyquil: most of the circuit languages are more or less equivalent. They allow a basic gate set (H, CNOT, etc) and measurement. Pyquil offers hybrid instructions, which makes it a slight step above previous circuit languages. Essentially, this class of languages is for expressing raw quantum circuits in code, while electing not to offer abstractions. - QA-Prolog: A quantum-annealer compiler for a subset of prolog. It is similar to a lot of other quantum annealing languages. Essentially, users can express problems in a very similar format to how problems are expressed classically, but users can only express a restricted subset of problems. Quantum annealers have their uses, but, generally speaking, they are not as powerful or general as gate-model computers. - Robert Tucci&#8217;s work:</p>
<p>I just believe that it&#8217;s better to attempt making something, even just a prototype of a prototype, because this will allow us to learn how to design quantum programming languages of the future. I&#8217;m reminded of the history of the C programming language: Dennis Ritchie&#8217;s and Brian Kernighan&#8217;s C is the basis for a large part of modern software. However, before it, there was B and BCPL, as well as languages before that. The goal of this project is to write the precursor to one of these languages: I&#8217;d like to create minimal abstractions that allow for easier modeling.</p>
<p>Now, I believe that the source of these abstractions can be rooted in some kind of quantum data types.</p>
<p>Models will fundamentally be composed of, generally, wave functions: Superpositions over all possible states. First, consider modeling a classical distribution. We can successfully produce sampleable classical distributions on a quantum computer. For instance, consider the following model from the Church programming language tutorial (a probabilistic context-free grammar):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" data-line-number="1">(<span class="ex">define</span><span class="fu"> </span>(transition nonterminal)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  (<span class="kw">case</span> nonterminal</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">        ((&#39;D) (multinomial(<span class="kw">list</span> (<span class="kw">list</span> (terminal &#39;the))</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">                                (<span class="kw">list</span> (terminal &#39;a)))</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">                          (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>))))</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        ((&#39;N) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> (terminal &#39;chef))</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">                                 (<span class="kw">list</span> (terminal &#39;soup))</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                                 (<span class="kw">list</span> (terminal &#39;omelet)))</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">                           (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">3</span>) (<span class="op">/</span> <span class="dv">1</span> <span class="dv">3</span>) (<span class="op">/</span> <span class="dv">1</span> <span class="dv">3</span>))))</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        ((&#39;V) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> (terminal &#39;cooks))</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                                 (<span class="kw">list</span> (terminal &#39;works)))</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                           (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>))))</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">        ((&#39;A) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> (terminal &#39;diligently)))</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">                           (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">        ((&#39;AP) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> &#39;A))</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">                            (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">        ((&#39;NP) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> &#39;D &#39;N))</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">                            (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">        ((&#39;VP) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> &#39;V &#39;AP)</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">                                  (<span class="kw">list</span> &#39;V &#39;NP))</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">                            (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="op">/</span> <span class="dv">1</span> <span class="dv">2</span>))))</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">        ((&#39;S) (multinomial (<span class="kw">list</span> (<span class="kw">list</span> &#39;NP &#39;VP))</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">                           (<span class="kw">list</span> (<span class="op">/</span> <span class="dv">1</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">        (<span class="kw">else</span> &#39;error)))</a></code></pre></div>
<p>More succinctly, this is specifying the following (toy) language model:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb2-1" data-line-number="1">D(eterminer): (uniform &#39;the&#39; &#39;a&#39;)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">N(oun): (uniform &#39;chef&#39; &#39;omelet&#39; &#39;soup&#39;)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">V(erb): (uniform &#39;cooks&#39; &#39;works&#39;)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">A(dverb): (uniform &#39;diligently&#39;)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">AP(Adverb Phrase): (uniform A)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">NP(Noun Phrase): (D, N)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">VP(Verb Phrase): (uniform (V AP) (V NP))</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">S(entence): (NP, VP)</a></code></pre></div>
<p>We can model this in curry using similar multinomial distributions and local classical mappings. To make things even simpler, let&#8217;s first just consider modeling a randomly sampled Noun-Phrase (which is the first part in sampling a full toy sentence). The noun-phrase is a concatenation of a determiner and a noun. In our toy example, we have two determiners and three nouns, both uniformly sampled, which makes for a total of six options with equal probability. So, we&#8217;ll need three qubits to model this. Curry has builtins for these distributions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb3-1" data-line-number="1">(def determiner-qubit <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">(def noun-qubits <span class="dv">1</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">(bernoulli <span class="fl">0.5</span> determiner-qubit)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">(multinomial <span class="fl">0.33</span> <span class="fl">0.33</span> <span class="fl">0.34</span> noun-qubits)</a></code></pre></div>
<p>The output is the following (using a local simulator):</p>
<pre><code>grid {curry}: ./compile examples/test.lisp

[[&#39;def&#39;, &#39;determiner-qubit&#39;, &#39;0&#39;],
 [&#39;def&#39;, &#39;noun-qubits&#39;, &#39;1&#39;, &#39;2&#39;],
 [&#39;bernoulli&#39;, &#39;0.5&#39;, &#39;determiner-qubit&#39;],
 [&#39;multinomial&#39;, &#39;0.33&#39;, &#39;0.33&#39;, &#39;0.34&#39;, &#39;noun-qubits&#39;]]

{&#39;000&#39;: 0.17, &#39;001&#39;: 0.16, &#39;010&#39;: 0.17, &#39;011&#39;: 0.17, &#39;100&#39;: 0.16, &#39;101&#39;: 0.16}

277.4035930633545 ms simulated runtime</code></pre>
<p>In our output, the rightmost bit is representing the determiner, and the other two bits are representing the noun. So the output is (sic):</p>
<pre class="python3"><code>{&#39;the chef&#39; : 1/6, &#39;a chef&#39; : 1/6, &#39;the omelet&#39; : 1/6, &#39;a omelet&#39; : 1/6, &#39;the soup&#39; : 1/6, &#39;a soup&#39; : 1/6}</code></pre>
<p>Curry contains functionality to decode what these bits mean, but I will explain this in detail later.</p>
<p>Now, let&#8217;s consider the rest of the model. When we sample a Verb Phrase, it contains recursive elements. So, it will branch (with equal probabilities) to either (V AP) or (V NP). Before diving in, let&#8217;s look at branching in quantum computers.</p>
<p>Consider preparing a bell state:</p>
<pre><code>(h 0)
(cnot 0 1)</code></pre>
<p>And distinguish this from the following, which will produce the same classical measurements, but no entanglement (because the state of the first qubit is known before producing the state in the second qubit). In this case, the state 01 is possible, because the first qubit may be measured in the 1 state, and the second qubit is unprepared, and in the zero state.</p>
<pre><code>(bernoulli 0.5 0)
(measure 0 0)
(if 0 (x 1) (nop))</code></pre>
<p>So, when creating a probabilistic model which branches, we distinguish between these two types of branching, because only one truly creates an entangled state. However, this makes representing information slightly more difficult, because we will not know which bits correspond to which states (unless we encode this, which we will).</p>
<p>First, consider an example that produces the probability distribution: <code>[1/12, 1/12, 1/12, 1/12, 1/12, 1/12, 1/8, 1/8, 1/12, 1/12, 1/12]</code>. We can produce this by a simple:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb8-1" data-line-number="1">(def space <span class="dv">0</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">(multinomial <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">8</span>, <span class="dv">1</span>/<span class="dv">8</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span>, <span class="dv">1</span>/<span class="dv">12</span> space)</a></code></pre></div>
<p>But obviously this requires computing the distribution in advance. Another possibility is the following:</p>
<pre><code>(def workspace 1 2)
(bernoulli 0.5 0) ; Deciding NP or VP
(clear 0 0)
(if 0 
    ; if NP
    (do (bernoulli 0.5 0) ; Deciding D of NP
        (uniform 3 1 2))  ; Deciding N of NP
    ; if VP
    (do (bernoulli 0.5 0) ; Deciding V,AP or V,NP
        (clear 0 0)
        (if 0
            ; if V,AP
            (bernoulli 0.5 0)) ; Deciding V of V,AP
            ; if V,NP
            (do (bernoulli 0.5 0)  ; Deciding V of V, NP
                (bernoulli 0.5 1)  ; Deciding D of NP
                (uniform 3 2 3)))) ; Deciding N of NP</code></pre>
<p>Still, there&#8217;s a better way:</p>
<pre><code></code></pre>
