%% Paper based on a template by Michael Shell
%% see http://www.michaelshell.org/
%% for current contact information.
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% http://www.ieee.org/

%% Original Legal notice for LPPL (Latex Project Public License)
%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***

\documentclass[journal]{IEEEtran}
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[journal]{../sty/IEEEtran}

% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)

% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.

% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.

% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and 
% Axel Sommerfeldt. This package may be useful when used in conjunction with 
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/pkg/endfloat
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a 
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Qurry: A prototype quantum programming language}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%

\author{Lucas~Saldyt,~\IEEEmembership{Arizona State University}
\thanks{}}

% note the % following the last \IEEEmembership and also \thanks - 
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
% 
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.

% The paper headers
\markboth{Second International Conference On Quantum Compilation}%
{Second International Conference On Quantum Compilation}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.

% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2015 IEEE}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark.

% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\begin{abstract}
    The core philosophy of Qurry is that simple language features, in aggregate, can make quantum programming significantly easier, by offering lightweight abstractions in the spirit of modern C++.
    This allows users to implement quantum algorithms cleanly, without glossing over necessary lower-level details of quantum computing, such as the abstract topology of a particular computer.
    Qurry takes a top-down approach, moving from the abstract goal of creating higher-order functions and datatypes to the level of individual language features.
    While the desired semantics of a true quantum programming language are not yet completely crystalized, the creation of simple language abstractions will elevate the level at which quantum programs are thought about, potentially enlightening the creation of a true quantum programming language.
    Many existing quantum programming languages are truly circuit languages, with few features above the level of gates, and sometimes rudimentary functions or macros, and there is currently a tendency not to stray very far from this model.
    Lastly, Qurry is not just a language, but a software ecosystem which is meant to catalyze the development of quantum programming languages.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
    Quantum Computing, Programming Languages
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}

\IEEEPARstart{I}{nnovation} in near-term quantum programming requires the use of lightweight abstractions. 
Lightweight abstractions, as defined by Bjarne Stroustrup [TODO: Cite], are abstractions that lower the cognitive load on the user, without sacrificing understanding of the underlying processes behind particular code.
Layers of abstraction are a fundamental idea in all of computer science, and quantum computing is no different.
Currently, quantum computing operates on the abstraction that is the gate-level, where programs are defined by gates acting sequentially on particular qubits, instead of, for instance, specific microwave pulses (or another implementation-specific low-level mechanism).
The universal gate model of quantum computing generally allows a quantum programmer to ignore many details of the quantum computer they are running on: Sources of error aside, modeling the bond energy of molecular hydrogen is hypothetically the same on an ion-trap quantum computer as on a superconducting quantum computer.
However, some have argued for the importance of hardware, as in Google's phrase ``hardware aware, not hardware agnostic``. [TODO: Cite]
Many aspects of hardware are particularly important, for instance, topology, which will potentially result in a programmer needing to modify a quantum algorithm for it to run on two separate computers.
The goal of lightweight abstractions is to preserve these concerns, while still taking burden off of the programmer, and giving them a richer language with which to express themselves.

Quantum computing [motivations]

[TODO: General motivations, cite Rigetti, cite Haskell/LISP/Rich Hickey, cite Probabilistic programming languages]
[Cite Peter Selinger's papers]

Lastly, the matrix operator model of quantum computing actually lends itself to functional programming paradigms quite nicely, because quantum programs and quantum operators are functions in a sense.
Additionally, since quantum states are fixed once measured, and are generally measured at the end of a program, in a sense memory is not truly mutated (even though it appears to be). 
[i.e. $result = Pv$, not $result = 0; Pv$].
A quantum program itself is simply a higher order function, which operates on an initial state vector.
In turn, a particular quantum program is composed further of simpler matrix-functions, which operate on their own vectors, or are composed with other matrices.
For instance, consider a bell state program. 
As a whole, we may call the bell state program which creates the $+$ state $B$, and know that $B 0$ [TODO: Dirac notation] is the application of the program $B$ to a two-element zero vector.
However, this program will further be composed as a Hadamard operator, $H$, and entanglement operator, $CNOT$, where $H$ will operate on one qubit, and then $CNOT$ will operate on both qubits. [TODO: Math writeup]

In a traditional circuit language, these operators are composed by simply listing which qubits they operate on, and ordering them correctly in a circuit definition file.
However, with higher-order functions, quantum operators can be composed in mariad helpful ways, as is common in function languages like Haskell or LISP (from which Qurry draws many influences).

In addition to being a prototype quantum programming language, Qurry defines a software stack surrounding the language, which is intended to make development more pleasant.
For instance, this software stack makes it exceptionally easy to add new language features and libraries to Qurry.
This allows one to rapidly test new ideas in quantum programming and let the language evolve on its own as opposed to architecting a top-down ``perfect'' language.

Since quantum computers are simply special probabilistic computers, Qurry also attempts to create a classical statistical library for high-level modeling. 
This is particularly useful in the same way that a classical probabilistic programming language is, namely for modeling anything statistical, and especially for bayesian machine learning.
For instance, the R. Tucci and H. Dekant's group have shown uses for this through their software, Bayesforge [TODO: Cite].
Qurry includes simple statistical packages for creating states, but no inference engine.
[However, Qurry might allow one to interface with Bayesforge]

\section{Features}

    Qurry as a language is simply a circuit language with an overlay of higher-order functions.
    [Explain circuit languages and the functionality Qurry includes here, through pyquil]

    \subsection{Higher Order Functions}

    The simplest overlay is quite trivial. It is the $map$ function, which allows an arbitrary quantum operator to be applied to several qubits. 
    For instance, the operation $(map H myqubits)$ does a hadamard state preparation, which is common in the beginning of some quantum algorithms.
    While simple, this example is important because $map$ is a higher-order function.
    Namely, $map$ takes two arguments: first, a linear operator on qubits, and second, a block of qubits where the linear operator is applied to each qubit in the block.
    Because this first argument is itself a linear operator (a function of sorts [TODO: Verify]), $map$ is a higher-order function.
    Higher-order functions are already used implicitly when composing linear operators to create a quantum program, so it makes sense to expose them.
    [Discuss the $map$ construct].

    Additionally, many constructs are defined in terms of unitary gates. Any of these is also a higher-order function.
    A still simple but more useful example is a controlled unitary.
    First, consider a unitary that is controlled from one bit:


    \begin{itemize}
        \item cascade 	    
        \item clear 	    
        \item cond 	    
        \item do 	        
        \item macro 	    
    \end{itemize}

    \subsection{Higher Order Datatypes}

    [discuss define [TODO: memory model]]

    Equally important is the ability to create higher-order datatypes.
    Instead of operating on the level of qubits, are able to arrange raw datatypes into more complex structures.
    The simplest, which is common in any quantum circuit language, is the ability to create arrays of qubits.
    [Discuss the $block$ construct].

    However, for full completeness, one must be able to arrange qubits into special structures, in the sense of C++ structs.
    Further, in object oriented programming, classes are essentially equivalent to structs, and then collections of functions that operate on a struct.
    For simplicity, elegance, and robustness, Qurry does not implement encapsulation or inheritance, but instead uses public access by default (in the spirit of Python, since after all, Qurry has a Python interface), and relies on composition instead of inheritance.
    [Discuss the $datatype$ construct].
    With the inclusion of composable data structures, users are able to create arbitrarily nested structures of qubits with semantically named fields.

    Recursively composed higher-order datatypes, in combination with recursively composed higher-order functions are the foundation for creating a more abstract programming language.

    At time of writing, Qurry contains the following constructs:  	
    \begin{itemize}
	    \item gaussian 	
        \item bernoulli
	    \item multinomial 	
	    \item uniform
    \end{itemize}

    [TODO: Elaborate on each]

\section{Standard Library}

    Explain how the statistics library can be easily implemented.

\section{Comparisons}

    Draw examples from Nielsen and Chuang, and the general literature.

\section{Conclusion}

In the creation of a Qurry and its corresponding framework, it is hoped that this will aid the development of quantum algorithms, as algorithm designers will have a new, richer, more abstract vocabulary with which to express themselves.
To recap, this goal is approached in the following N ways.
By introduction of lightweight abstractions from the C++ school of thought, efficient and transparent programming interfaces are created.
Through specialized libraries, Qurry can claim to be a generalized library, while still offering powerful sub-frameworks for specific tasks.
With functional programming paradigms, Qurry can move towards higher levels of abstraction as the semantics of quantum programming become better understood.
Lastly, by creating a rapid prototyping framework, new language features can be developed in a bottom-up style, which will allow Qurry to be created naturally, instead of artificially.


% \IEEEPARstart{Q}{uantum} computing is still in a nascent form, especially when it comes to programming interfaces. 
% Many acclaimed quantum programming languages are simply circuit description languages that add superfluous syntax to have the look and feel of a traditional programming language.
% These interfaces generally lack abstraction, which is an essential feature of any programming language.
% In addition, a good number of quantum programming languages do not compile to run on actual hardware.
% A simple circuit language like QASM does not provide the hybrid computation like QUIL does.
% In effect, most quantum languages that do anything non-trivial are still circuit-assembly languages.
% The world of classical programming languages was revolutionized with the invention of the C programming language, which is now ubiquitous in today's software either in either its original or derivative forms [Cite]. 
% When C was created, it replaced assembly and eased the production of many important systems.
% For instance, the unix operating system was re-written in C, which greatly reduced its complexity.
% 
% Since quantum computers are inherently probabilistic, a quantum programming language can draw inspiration from classical probabilistic programming.
% Classical probabilistic programming languages are a recent innovation from the MIT cognitive science community. 
% Essentially, they create a way for non-expert programmers to access the power of Bayesian inference. 
% Users can create simple probabilistic models in standard code, and then run them through an expert-created inference backend.
% Famously, this has resulted in dramatically reduced code complexity, with a famous case where a 50-line probabilistic program could compete with traditional approaches to face recognition [TODO: Cite].
% 
% Both quantum computing and classical probabilistic programming have variables which are probability distributions.
% In quantum computing, measuring a single qubit results in $0$ or $1$, which represents a bernoulli trial, even though the qubit's pre-measurement state is richer (because its true representation is a complex probability amplitude).
% If this is repeated multiple times, it creates a binomial distribution.
% Similarly, measuring multiple ($n$) qubits gives a bitstring $(0, 1)^n$. 
% If this is repeated multiple times, it creates a multinomial distribution.
% 
% Quantum states are richer than standard probability distributions.
% The simplest case is a Bell state, where, for instance, one may measure $00$ or $11$ with equal probability\dots [TODO: Extend]

% \section{Background}
% 
% \section{Curry}
% 
% Curry builds atop the innovations of Rigetti pyquil.
% Pyquil is simply used as a compilation target for higher level constructs.
% For example, pyquil does not provide a native ``if`` statement, and istead relies on hardcoded jumps.
% The if statement is the simplest element in Curry:
% 
% Simply change (if (condition) (branch) (branch))
% into
% ``
% Condition
% Measure []
% Jump label
% branch
% branch etc
% ``
% 
% Curry also supports variable naming, blocks of qubits, classical callbacks, imports, \dots
% Curry can be called as a library and operated from python
% 
% The backend for code generation allows different targets, such as google Circ.

%% These resulting multinomial distributions can, in theory, represent everything, but are often made to amplify a single state such that it can be found with high probability after doing multiple experiments. This is done because $n$ qubits have at most $2^n$ possible measurement outcomes and it is difficult to estimate the true probability distribution?. -> Not certain about this please research more

% # Brainstorm for a Probabilistic Quantum Programming Language
% 
% Modern quantum programming, despite its progress, is still esoteric to the average programmer. 
% In general, programming languages offer a midway point between a person's mental model and literal machine instructions.
% So, the question to be resolved is: How do most programmers model algorithms, and what intermediates can make it easier to turn mental models into code?
% 
% There are two main goals for providing abstractions in quantum programming:
%  - Allow novices to more quickly create useful and interesting models
%  - Allow experienced programmers to create models more efficiently, so that they can focus on more important design aspects
% 
% Previous attempts at designing quantum programming languages can give insights for the design of new ones:
% First, there are circuit languages, which provide no abstraction, but are useful for interfacing with normal languages or compiling into.
% Circuit languages are also adequate for those who are already experienced with quantum programming.
% Second, there are the quantum-annealing family of languages, which can actually provide abstraction, but limit the scope of solvable problems.
% Third, there are existing attempts at higher-level universal gate languages.
% 
% I'll chose one example from each class:
%  - Most of the circuit languages are more or less equivalent. They allow a basic gate set (H, CNOT, etc) and measurement. Rigetti pyquil offers hybrid instructions, which makes it a slight step above previous circuit languages. Essentially, this class of languages is for expressing raw quantum circuits in code, while intentionally electing not to offer abstractions. This class of languages will be useful to compile into.
%  - QA-Prolog: A quantum-annealer compiler for a subset of prolog. It is similar to a lot of other quantum annealing languages. Essentially, users can express problems in a very similar format to how problems are expressed classically, but users can only express a restricted subset of problems. Quantum annealers have their uses, but, generally speaking, they are not as powerful or general as gate-model computers. The abstraction offered, however, is worth mimicking.
%  - Robert Tucci's work ("Quantum Fog", "Qubiter"): Tucci's work offers modeling of bayesian networks on quantum computers, and is an interesting sister project to this one. I think that this is moving in the correct direction, by balancing usefulness with expressivity.
% 
%  Considering each of the above, I believe that there is an interesting gap to be filled: That of a language which offers lightweight abstractions, but still allows the general power of quantum computing.
% Of course, this is a big goal, and likely one that will only be partially fulfilled.
% I believe that it's better to attempt making something, even just a prototype of a prototype, because this will allow us to learn how to design quantum programming languages of the future.
% I'm reminded of the history of the C programming language: Dennis Ritchie's and Brian Kernighan's C is the basis for a large part of modern software. 
% However, before it, there was B and BCPL, as well as languages before that.
% The goal of this project is to write the precursor to one of these languages: I'd like to create minimal abstractions that allow for easier modeling.
% 
% There are some easy targets for providing abstraction: common things like functions, conditionals, loops, integer data types, and so on. 
% However, let's jump into the quantum/probabilistic side of things.
% 
% Models will fundamentally be composed of, generally, wave functions: Superpositions over all possible states.
% First, consider modeling a classical distribution. 
% We can successfully produce sampleable classical distributions on a quantum computer.
% For instance, consider the following model from the Church programming language tutorial.
% This code is specifying a probabilistic grammar for simple sentences about cooking.
% 
% ```scheme
% (define (transition nonterminal)
%   (case nonterminal
%         (('D) (multinomial(list (list (terminal 'the))
%                                 (list (terminal 'a)))
%                           (list (/ 1 2) (/ 1 2))))
%         (('N) (multinomial (list (list (terminal 'chef))
%                                  (list (terminal 'soup))
%                                  (list (terminal 'omelet)))
%                            (list (/ 1 3) (/ 1 3) (/ 1 3))))
%         (('V) (multinomial (list (list (terminal 'cooks))
%                                  (list (terminal 'works)))
%                            (list (/ 1 2) (/ 1 2))))
%         (('A) (multinomial (list (list (terminal 'diligently)))
%                            (list (/ 1 1))))
%         (('AP) (multinomial (list (list 'A))
%                             (list (/ 1 1))))
%         (('NP) (multinomial (list (list 'D 'N))
%                             (list (/ 1 1))))
%         (('VP) (multinomial (list (list 'V 'AP)
%                                   (list 'V 'NP))
%                             (list (/ 1 2) (/ 1 2))))
%         (('S) (multinomial (list (list 'NP 'VP))
%                            (list (/ 1 1))))
%         (else 'error)))
% ```
% 
% More succinctly, this is specifying the following (toy) language model:
% ```scheme
% D(eterminer):      (uniform 'the' 'a')
% N(oun):            (uniform 'chef' 'omelet' 'soup')
% V(erb):            (uniform 'cooks' 'works')
% A(dverb):          (uniform 'diligently')
% AP(Adverb Phrase): (uniform A)
% NP(Noun Phrase):   (D, N)
% VP(Verb Phrase):   (uniform (V AP) (V NP))
% S(entence):        (NP, VP)
% ```
% 
% What's the best way to model something like this on a quantum computer?
% To make things even simpler, let's first just consider modeling a randomly sampled Noun-Phrase (which is the first part in sampling a full toy sentence).
% The noun-phrase is a concatenation of a determiner and a noun. In our toy example, we have two determiners and three nouns, both uniformly sampled, which makes for a total of six options with equal probability.
% So, we'll need three qubits to model this. Curry has builtins for these distributions.
% ```scheme
% (def determiner-qubit 0)
% (def noun-qubits 1 2)
% (bernoulli 0.5 determiner-qubit)
% (multinomial 0.33 0.33 0.34 noun-qubits)
% ```
% 
% The output is the following (using a local simulator):
% ```
% grid {curry}: ./compile examples/test.lisp
% 
% [['def', 'determiner-qubit', '0'],
%  ['def', 'noun-qubits', '1', '2'],
%  ['bernoulli', '0.5', 'determiner-qubit'],
%  ['multinomial', '0.33', '0.33', '0.34', 'noun-qubits']]
% 
% {'000': 0.17, '001': 0.16, '010': 0.17, '011': 0.17, '100': 0.16, '101': 0.16}
% 
% 277.4035930633545 ms simulated runtime
% ```
% 
% In our output, the rightmost bit is representing the determiner, and the other two bits are representing the noun.
% So the output is:
% ```python3
% {'the chef' : 1/6, 'a chef' : 1/6, 'the omelet' : 1/6, 'a omelet' : 1/6, 'the soup' : 1/6, 'a soup' : 1/6}
% ```
% Curry contains functionality to decode what these bits mean, but I will explain this in detail later.
% 
% Now, let's consider the rest of the model.
% When we sample a Verb Phrase, it contains recursive elements.
% So, it will branch (with equal probabilities) to either (V AP) or (V NP).
% Before diving in, let's look at branching in quantum computers.
% 
% Consider preparing a bell state:
% ```
% (h 0)
% (cnot 0 1)
% ```
% And distinguish this from the following, which will produce the same classical measurements, but no entanglement (because the state of the first qubit is known before producing the state in the second qubit). 
% In this case, the state 01 is possible, because the first qubit may be measured in the 1 state, and the second qubit is unprepared, and in the zero state.
% ```
% (bernoulli 0.5 0)
% (measure 0 0)
% (if 0 (x 1) (nop))
% ```
% 
% So, when creating a probabilistic model which branches, we distinguish between these two types of branching, because only one truly creates an entangled state.
% However, this makes representing information slightly more difficult, because we will not know which bits correspond to which states (unless we encode this, which we will).
% 
% First, consider an example that produces the probability distribution:
% `[1/12, 1/12, 1/12, 1/12, 1/12, 1/12, 1/8, 1/8, 1/12, 1/12, 1/12]`.
% We can produce this by a simple:
% ```scheme
% (def space 0 3)
% (multinomial 1/12, 1/12, 1/12, 1/12, 1/12, 1/12, 1/8, 1/8, 1/12, 1/12, 1/12 space)
% ```
% But obviously this requires computing the distribution in advance.
% Another possibility is the following:
% ```
% (def workspace 1 2)
% (bernoulli 0.5 0) ; Deciding NP or VP
% (clear 0 0)
% (if 0 
%     ; if NP
%     (do (bernoulli 0.5 0) ; Deciding D of NP
%         (uniform 3 1 2))  ; Deciding N of NP
%     ; if VP
%     (do (bernoulli 0.5 0) ; Deciding V,AP or V,NP
%         (clear 0 0)
%         (if 0
%             ; if V,AP
%             (bernoulli 0.5 0)) ; Deciding V of V,AP
%             ; if V,NP
%             (do (bernoulli 0.5 0)  ; Deciding V of V, NP
%                 (bernoulli 0.5 1)  ; Deciding D of NP
%                 (uniform 3 2 3)))) ; Deciding N of NP
% ```
% 
% Still, there's a better way, and that's what's currently in progress:
% 
% ```
% ...
% ```

% \section{Untitled}
% 
% Since quantum computers are generally only better at specialized tasks [TODO: Cite?], it makes more sense for quantum computation to be hybridized: to utilize both classical and quantum computers.
% This philosophy is largely exhibited by Rigetti pyquil, which is callable from the Python programming language, which is widely used in today's software development. 
% While Curry is a standalone language that compiles into Rigetti pyquil, it will also be available as a Python library, such that Python programmers can simply use their existing knowledge


% if have a single appendix:
%\appendix[Proof of the Zonklar Equations]
% or
%\appendix  % for no appendix heading
% do not use \section anymore after \appendix, only \section*
% is possibly needed

% use appendices with more than one appendix
% then use \section to start each appendix
% you must declare a \section before using any
% \subsection or using \label (\appendices by itself
% starts a section numbered zero.)

 %\appendices
 %\section{}
 %Appendix one text goes here.
 %
 %% you can choose not to have a title for an appendix
 %% if you want by leaving the argument blank
 %\section{}
 %Appendix two text goes here.


% use section* for acknowledgment
\section*{Acknowledgment}

The author would like to thank Dr. Will Zeng of Rigetti computing, an organizer of the Unitary Fund, Dr. Ajay Bansal of Arizona State University, PLoS and other donators to the unitary fund, and ASU's FURI program.

% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}

% biography section
% 
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiographynophoto}{Lucas Saldyt}
    is currently a student researcher at Arizona State University, and has previously worked for Sandia National Laboratories and Los Alamos National Laboratories as a student intern in the quantum computing department.
\end{IEEEbiographynophoto}

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}

% that's all folks
\end{document}



